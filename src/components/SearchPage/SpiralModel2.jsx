


/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useCallback, useMemo, useState } from "react";
import { useGLTF, PerspectiveCamera, useAnimations } from "@react-three/drei";
//import model from './vs-with-animation-3.glb';
import model from './vs-with-animation-2.glb';
import * as THREE from 'three';
import { useFrame } from "@react-three/fiber";

let mix;
let m;
let clip = [];
let a = 0;

export default function Model(props) {
  const group = useRef();
  const [index, updateIndex] = useState(false);
  const { nodes, materials, animations } = useGLTF(model);
  const { mixer, actions, clips } = useAnimations(animations, group);
  let mats = Object.entries(materials);

  const spiral = useRef();

  //const camera = useRef();

  useMemo(() => {

    for (const a in materials){

        materials[a].onBeforeCompile = (shader) => {

          shader.uniforms.time = { value: 0 };
          shader.uniforms.index = { value: 0 };
    
          shader.vertexShader = `
            uniform float time;\n
            uniform float index;\n
            varying vec3 worldPos;\n
            varying vec3 norms;\n
            varying vec3 pos;\n
            ` + shader.vertexShader;
          shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            [
              'pos = position;',
              'vec3 norm = vNormal.xyz;',
              'worldPos = (modelMatrix * vec4(position, 1.)).xyz;',
              'norms = normal;',
              //'pos.z += sin(time + pos.z * pos.x + pos.x) * .1;',          
              //'pos.x += cos(time + (pos.z * 2.0)) * .1;',              
              //'pos.z += sin(time + (pos.x * 2.0)) * .1;',
              'vec3 transformed = vec3( position );',
              //'vNormal = vNormal;'
            ].join( '\n' )
          );
/*
          shader.fragmentShader = `
          uniform float time;\n
          uniform float index;\n
          varying vec3 worldPos;\n
          varying vec3 norms;\n
          varying vec3 pos;\n
          ` + shader.fragmentShader;

          shader.fragmentShader = shader.fragmentShader.replace(
            `#include <dithering_fragment>`,
            `
              vec3 uLight = vec3(20, 0, 25);
              vec3 lightDir = normalize( uLight - worldPos );
              float diffuse = max(0., dot(norms, lightDir) );
              float dist = length(uLight - pos);
              gl_FragColor = vec4( 1. / vec3(dist) * 3. , 1);
            `
          );          
*/
          //console.log(THREE.ShaderChunk.dithering_fragment)
  
          materials[a].userData.shader = shader;
      }
    }
    /*
    materials['Material.010'].needsUpdate = true;    
    materials['Material.010'].onBeforeCompile = (shader) => {

      shader.uniforms.time = { value: 1 };

      shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
      shader.vertexShader = shader.vertexShader.replace(
        '#include <begin_vertex>',
        [
          'vec3 pos = position;',
          'vec3 norm = vNormal.xyz;',
          //'pos.z += sin(time + pos.z * pos.x + pos.x) * .1;',          
          'pos.z += sin(time + (pos.x * 0.5)) * .1;',
          'vec3 transformed = vec3( pos );',
          'vNormal = vNormal;'
        ].join( '\n' )
      );

      materials['Material.010'].userData.shader = shader;
*/
  //}, [materials]

},  [ materials['Material.001'] ])


  useFrame((state, time) => {

    if(index){
        mix.play().setLoop(THREE.LoopOnce).halt(2.3);

        //rotating spiral planes
        spiral.current.rotation.y = state.clock.getElapsedTime() * 0.1;
    }

  })


  useEffect(() => {

    //console.log(props)
    //props.update = index;
    props.update['s1'] = updateIndex

    m = mixer;
    //m.timeScale = 2.;  
    clip[0] = clips[0];
    mix = mixer.clipAction(clips[0]);
    mix.weight = 0.99;

    // taking the end of the animation out, the end starts at the beginning moves the planes back to the starting position
    //mixer.timeScale = 1.;
    //mixer.clipAction(clips[0]).play().setLoop(THREE.LoopOnce).halt(2.5);

    /*
    m = mixer;
    //m.timeScale = 2.;  
    clip[0] = clips[0];
    mix = mixer.clipAction(clips[0]);
    mix.weight = 0.99;
    mix.play().setLoop(THREE.LoopOnce).halt(2.5);
    */
    
    if( materials['Material.010'].userData.shader ){
/*
      if(index < mats.length){
        mats[index][1].userData.shader.uniforms.time.value = props.time;
        updateIndex((index) => index += 1);
        //console.log(index)
      }
      else{
        updateIndex((index) => index = 0);
      }
*/

      for (const a in materials){
        materials[a].userData.shader.uniforms.time.value = props.time;
        //materials[a].userData.shader.uniforms.index.value = index;        
        //updateIndex(() => index + 1);
      }
      //updateIndex(0);
      

      //console.log(    materials['Material.010'].userData.shader )
      //materials['Material.010'].userData.shader.uniforms.time.value = props.time;
    }
    
    //console.log(props)
    //console.log(materials['Material.001']);       

  }, [])
  /* 
        <PerspectiveCamera
          ref={props.cam}
          name="Camera"
          makeDefault = { true }
          far={1000}
          near={0.1}
          fov={22.895}
          position={[0, 5.05, 10.813]}
        />  

        <pointLight
          name="Spot"
          intensity={6.389}
          decay={2}
          position={[0, 6.228, -0.061]}
          rotation={[-Math.PI / 2, 0, 0]}
        />


  */

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <PerspectiveCamera
          ref={props.cam}
          name="Camera"
          makeDefault = { true }
          far={1000}
          near={0.1}
          fov={22.895}
          position={[0, 5.05, 15.813]}
        />
        <pointLight
          name="Spot"
          //intensity={15.389}
          intensity={55.389}          
          decay={3.5}
          position={[0, 6.228, -0.061]}
          rotation={[-Math.PI / 2, 0, 0]}
        />
        <group name="Plane006" ref={spiral} rotation={ [0, 0, 0] }>
          <mesh
            name="Plane006_1"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_1.geometry}
            material={materials["Material.010"]}
            morphTargetDictionary={nodes.Plane006_1.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_1.morphTargetInfluences}
          />
          <mesh
            name="Plane006_2"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_2.geometry}
            material={materials["Material.005"]}
            morphTargetDictionary={nodes.Plane006_2.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_2.morphTargetInfluences}
          />
          <mesh
            name="Plane006_3"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_3.geometry}
            material={materials["Material.006"]}
            morphTargetDictionary={nodes.Plane006_3.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_3.morphTargetInfluences}
          />
          <mesh
            name="Plane006_4"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_4.geometry}
            material={materials["Material.004"]}
            morphTargetDictionary={nodes.Plane006_4.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_4.morphTargetInfluences}
          />
          <mesh
            name="Plane006_5"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_5.geometry}
            material={materials["Material.003"]}
            morphTargetDictionary={nodes.Plane006_5.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_5.morphTargetInfluences}
          />
          <mesh
            name="Plane006_6"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_6.geometry}
            material={materials["Material.007"]}
            morphTargetDictionary={nodes.Plane006_6.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_6.morphTargetInfluences}
          />
          <mesh
            name="Plane006_7"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_7.geometry}
            material={materials["Material.008"]}
            morphTargetDictionary={nodes.Plane006_7.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_7.morphTargetInfluences}
          />
          <mesh
            name="Plane006_8"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_8.geometry}
            material={materials["Material.009"]}
            morphTargetDictionary={nodes.Plane006_8.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_8.morphTargetInfluences}
          />
          <mesh
            name="Plane006_9"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_9.geometry}
            material={materials["Material.002"]}
            morphTargetDictionary={nodes.Plane006_9.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_9.morphTargetInfluences}
          />
          <mesh
            name="Plane006_10"
            castShadow
            receiveShadow
            geometry={nodes.Plane006_10.geometry}
            material={materials["Material.001"]}
            morphTargetDictionary={nodes.Plane006_10.morphTargetDictionary}
            morphTargetInfluences={nodes.Plane006_10.morphTargetInfluences}
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload(model);